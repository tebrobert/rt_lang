greeting = "Hey! What is your name?"
print(greeting)
name <- input
print("Welcome, " + name)


####################
- omg, remove endOfCode and endOfTokens
- The operator syntax - plan how it should work

    preparse_braced: [a ( b . c ) d] -> [a (c(b)) d]
    preparse_unary: [- - a - b - c] -> [--a - b - c]

    x = - - a ( - - b ) ( c ) + d ( + e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n # ALL TOKENS
    x = - - a ( - -b ) ( c ) + d ( + e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n
    x = - - a ( --b ) ( c ) + d ( + e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n # INNER parsed unary
    x = - - a (--b) ( c ) + d ( + e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n
    x = - - a (--b) (c) + d ( + e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n
    x = - - a (--b) (c) + d ( +e ) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n # INNER parsed unary
    x = - - a (--b) (c) + d (+e) ( f ) * g ( h ) ( i . j ( k ) ) . l ( m ) . n
    x = - - a (--b) (c) + d (+e) (f) * g ( h ) ( i . j ( k ) ) . l ( m ) . n
    x = - - a (--b) (c) + d (+e) (f) * g (h) ( i . j ( k ) ) . l ( m ) . n
    x = - - a (--b) (c) + d (+e) (f) * g (h) ( i . j (k) ) . l ( m ) . n
    x = - - a (--b) (c) + d (+e) (f) * g (h) ( i . j(k) ) . l ( m ) . n # INNER parsed calls
    x = - - a (--b) (c) + d (+e) (f) * g (h) ( i.j(k) ) . l ( m ) . n # INNER parsed dots
    x = - - a (--b) (c) + d (+e) (f) * g (h) (i.j(k)) . l ( m ) . n
    x = - - a (--b) (c) + d (+e) (f) * g (h) (i.j(k)) . l (m) . n # not ALL EXPR, parsed braced
    x = - - a(--b) (c) + d (+e) (f) * g (h) (i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d (+e) (f) * g (h) (i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d(+e) (f) * g (h) (i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d(+e)(f) * g (h) (i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d(+e)(f) * g(h) (i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d(+e)(f) * g(h)(i.j(k)) . l (m) . n
    x = - - a(--b)(c) + d(+e)(f) * g(h)(i.j(k)) . l(m) . n # parsed calls
    x = - - a(--b)(c) + d(+e)(f) * g(h)(i.j(k)).l(m) . n
    x = - - a(--b)(c) + d(+e)(f) * g(h)(i.j(k)).l(m).n # ALL EXPR, parsed dots
    x = - -a(--b)(c) + d(+e)(f) * g(h)(i.j(k)).l(m).n
    x = --a(--b)(c) + d(+e)(f) * g(h)(i.j(k)).l(m).n # parsed unary
    x = --a(--b)(c) + d(+e)(f)*g(h)(i.j(k)).l(m).n # parsed high
    x = --a(--b)(c)+d(+e)(f)*g(h)(i.j(k)).l(m).n # parsed low
    x=--a(--b)(c)+d(+e)(f)*g(h)(i.j(k)).l(m).n # parsed assignment


    Precedence:
    f(x)                    # ->
    l.r                     # ->
    +v, -v                  # <-
    not v                   # <-
    l*r, l/r, l%r           # ->
    l+r, l-r                # ->
    l<r, l<=r, l>r, l>=r    # ? ->
    l==r, l!=r              # ? ->
    l and r                 # ->
    l or r                  # ->

    l = r, l <- r           # ? <-


f(x)
a +(x)
- - (index) (nums)

=>          IDF   (expr)  -> CALL
.           IDF   (expr)  -> CALL
LIT         IDF ; (expr)  -> skip operator
IDF         IDF ; (expr)  -> skip operator
(expr)      IDF ; (expr)  -> skip operator
EXPR_CALL   IDF ; (expr)  -> skip operator
EXPR_LAMBDA IDF ; (expr)  -> skip operator
            IDF   (expr)  -> CALL



#Plan: ? add _FX _X to type params on both sides before synchronizing
