implement booleans

? implement one argument functions

?implement structs
?implement tuples
    implement functions
        implement overloadings

implement comments
implement escape-characters
implement better error locating
implement flags:
	validate
	build
	run (default)
implement map

Defer:
Unary plus, minus
Typeclasses
...


implement list type
? implement named tuple type
implement dict type
implement json type




def float(x: Int): Float

def str(x: Int): Str
def str(x: Float): Str
def str(x: Bool): Str
def str(x: Str): Str = id

def +(y: Int)(x: Int): Int
def +(y: has[float])(x: has[float]): Float
def +(y: has[str])(x: has[str]): Str

# anonymous functions
# anonymous structs
# "has" - anonymous trait


trait Plus[A, B]:
    def +(x: A, y: B): A
trait Multiply[A, B]:
    def *(x: A, y: B): A

impl Plus[Str, Str]:
    def +(x, y) = ...
impl Multiply[Str, Int]:
    def *(x, y) = ...

impl Plus[Int, Int]:
    def +(x, y) = ...
impl Multiply[Int, Int]:
    def *(x, y) = ...


impl Plus[Float, Int]:
    def +(x, y) = ...
impl Multiply[Float, Int]:
    def *(x, y) = ...


impl Plus[Int, Float]:
    def +(x, y): Float = ... ###############
impl Multiply[Int, Float]:
    def *(x, y): Float = ... ###############


# String - Arr[Char], Vec20[Char] ?
# 1. Plus functions


# list access
    #1
    [][0]   # Left(IdxOutOfRangErr)
    myEither.getOrDie("")

    #2
    [][0]   # RAISE ERROR!      # TRADITIONALLY, we should rely on a programmer

    #3
    [][0]   # doesn't compile
    xs[i]   # somehow requires the fact 0 <= i < xs.len, seems too hard to do

# division
    #1
    1 // 0  # Left(ZeroDivErr)

    #2
    1 // 0  # doesn't compile
    1 // x  # somehow requires the fact x!=0   # seems efforts won't worth it

    #
    1 // 0  # RAISE ERROR!  # TRADITIONALLY, we should rely on a programmer

    #
    1 // 0  # inf    # values of the Int type are also "inf", "-inf", "nan"

# Memory issues
    [0] * (1_000 ** 100)
    # raise error
    # None
    # doesn't compile
